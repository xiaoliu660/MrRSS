name: Release

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Release version (e.g., v1.1.0)'
        required: true
        type: string

jobs:
  create-release:
    name: Create Release
    runs-on: ubuntu-latest
    permissions:
      contents: write
    outputs:
      version: ${{ steps.get_version.outputs.version }}
      tag: ${{ steps.get_version.outputs.tag }}
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Get version from input
        id: get_version
        run: |
          VERSION="${{ github.event.inputs.version }}"
          # Remove 'v' prefix if present
          VERSION="${VERSION#v}"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "tag=v$VERSION" >> $GITHUB_OUTPUT

      - name: Update version in wails.json
        run: |
          VERSION="${{ steps.get_version.outputs.version }}"
          sed -i 's/"version": ".*"/"version": "'$VERSION'"/' wails.json
          sed -i 's/"productVersion": ".*"/"productVersion": "'$VERSION'"/' wails.json

      - name: Check if tag exists
        id: check_tag
        run: |
          git fetch --tags
          if git rev-parse ${{ steps.get_version.outputs.tag }} >/dev/null 2>&1; then
            echo "tag_exists=true" >> $GITHUB_OUTPUT
            echo "Tag ${{ steps.get_version.outputs.tag }} already exists"
          else
            echo "tag_exists=false" >> $GITHUB_OUTPUT
            echo "Tag ${{ steps.get_version.outputs.tag }} does not exist"
          fi

      - name: Create Git tag
        if: steps.check_tag.outputs.tag_exists == 'false'
        run: |
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          git add wails.json
          git commit -m "Release ${{ steps.get_version.outputs.tag }}" || echo "No changes to commit"
          git tag ${{ steps.get_version.outputs.tag }}
          git push origin ${{ steps.get_version.outputs.tag }}
          git push origin HEAD:${{ github.ref_name }}

      - name: Generate changelog
        id: changelog
        run: |
          VERSION="${{ steps.get_version.outputs.version }}"

          # Extract changelog for this version from CHANGELOG.md
          if [ -f "CHANGELOG.md" ]; then
            # Find the section for this version
            # Match pattern like "## [1.1.3] - 2025-11-22"
            awk -v ver="$VERSION" '
              BEGIN { found=0; print_section=0 }
              /^## \[/ {
                if (print_section) exit
                if ($0 ~ "\\[" ver "\\]") {
                  found=1
                  print_section=1
                  next
                }
              }
              print_section && /^## \[/ { exit }
              print_section { print }
              END {
                if (!found) {
                  print "## What'\''s Changed"
                  print ""
                  print "* Release version " ver
                }
              }
            ' CHANGELOG.md > RELEASE_NOTES.md
          else
            # Fallback to git log if CHANGELOG.md doesn't exist
            echo "## What's Changed" > RELEASE_NOTES.md
            git log $(git describe --tags --abbrev=0 HEAD^)..HEAD --pretty=format:"* %s (%h)" >> RELEASE_NOTES.md || echo "* Initial release" >> RELEASE_NOTES.md
          fi

          # Show what we extracted for debugging
          echo "=== Generated Release Notes ==="
          cat RELEASE_NOTES.md
          echo "==============================="

      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.get_version.outputs.tag }}
          name: MrRSS ${{ steps.get_version.outputs.tag }}
          body_path: RELEASE_NOTES.md
          draft: false
          prerelease: false
          token: ${{ secrets.GITHUB_TOKEN }}

  build-release:
    name: Build ${{ matrix.platform }}-${{ matrix.arch }}
    needs: create-release
    runs-on: ${{ matrix.os }}
    permissions:
      contents: write
    strategy:
      fail-fast: false
      matrix:
        include:
          # Linux AMD64 build
          - os: ubuntu-24.04
            platform: linux
            arch: amd64
            ext: ''
          # Linux ARM64 build - using native ARM64 runner
          - os: ubuntu-24.04-arm
            platform: linux
            arch: arm64
            ext: ''
          # Windows AMD64 build
          - os: windows-latest
            platform: windows
            arch: amd64
            ext: '.exe'
          # Windows ARM64 build - using native ARM64 runner
          - os: windows-11-arm
            platform: windows
            arch: arm64
            ext: '.exe'
          # macOS Universal build (includes both Intel and Apple Silicon)
          - os: macos-latest
            platform: darwin
            arch: universal
            ext: '.app'

    steps:
      - uses: actions/checkout@v6
        with:
          ref: ${{ needs.create-release.outputs.tag }}

      - name: Check if artifacts already exist
        id: check_artifacts
        shell: bash
        run: |
          # Get release info and check for existing assets
          TAG="${{ needs.create-release.outputs.tag }}"
          VERSION="${{ needs.create-release.outputs.version }}"

          # Determine expected artifact names for this platform/arch
          if [ "${{ matrix.platform }}" = "windows" ]; then
            INSTALLER="MrRSS-${VERSION}-windows-${{ matrix.arch }}-installer.exe"
            PACKAGE=""  # No package for Windows
          elif [ "${{ matrix.platform }}" = "linux" ]; then
            INSTALLER="MrRSS-${VERSION}-linux-${{ matrix.arch }}.AppImage"
            PACKAGE="MrRSS-${VERSION}-linux-${{ matrix.arch }}.tar.gz"
          elif [ "${{ matrix.platform }}" = "darwin" ]; then
            INSTALLER="MrRSS-${VERSION}-darwin-${{ matrix.arch }}.dmg"
            PACKAGE=""  # No package for macOS
          fi

          # Check if release has these assets
          RELEASE_JSON=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/releases/tags/${TAG}")

          ASSETS=$(echo "$RELEASE_JSON" | jq -r '.assets[].name')

          echo "Checking for existing assets..."
          echo "Expected installer: $INSTALLER"
          if [ -n "$PACKAGE" ]; then
            echo "Expected package: $PACKAGE"
          fi
          echo "Found assets:"
          echo "$ASSETS"

          # Check if any of our artifacts exist
          SKIP_BUILD="false"
          if echo "$ASSETS" | grep -q "$INSTALLER"; then
            echo "Installer for ${{ matrix.platform }}-${{ matrix.arch }} already exists in release"
            SKIP_BUILD="true"
          elif [ -n "$PACKAGE" ] && echo "$ASSETS" | grep -q "$PACKAGE"; then
            echo "Package for ${{ matrix.platform }}-${{ matrix.arch }} already exists in release"
            SKIP_BUILD="true"
          fi

          echo "skip_build=$SKIP_BUILD" >> $GITHUB_OUTPUT

          if [ "$SKIP_BUILD" = "true" ]; then
            echo "⏭️  Skipping build for ${{ matrix.platform }}-${{ matrix.arch }} (already exists)"
          else
            echo "✅ Proceeding with build for ${{ matrix.platform }}-${{ matrix.arch }}"
          fi

      - name: Set up Go
        if: steps.check_artifacts.outputs.skip_build == 'false'
        uses: actions/setup-go@v5
        with:
          go-version: '1.21'

      - name: Set up Node.js
        if: steps.check_artifacts.outputs.skip_build == 'false'
        uses: actions/setup-node@v6
        with:
          node-version: '20'

      - name: Install Linux dependencies (AMD64)
        if: steps.check_artifacts.outputs.skip_build == 'false' && matrix.platform == 'linux' && matrix.arch == 'amd64'
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            libgtk-3-dev \
            libwebkit2gtk-4.1-dev \
            libayatana-appindicator3-dev \
            gcc \
            pkg-config \
            wget \
            file

          # Verify webkit2gtk-4.1 is properly installed
          pkg-config --modversion webkit2gtk-4.1 || exit 1
          echo "webkit2gtk-4.1 installed successfully"

          # Create symlink for Wails v2 compatibility (looks for 4.0)
          sudo ln -sf /usr/lib/x86_64-linux-gnu/pkgconfig/webkit2gtk-4.1.pc /usr/lib/x86_64-linux-gnu/pkgconfig/webkit2gtk-4.0.pc
          echo "Created webkit2gtk-4.0 symlink for Wails compatibility"

      - name: Install Linux dependencies (ARM64)
        if: steps.check_artifacts.outputs.skip_build == 'false' && matrix.platform == 'linux' && matrix.arch == 'arm64'
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            libgtk-3-dev \
            libwebkit2gtk-4.1-dev \
            libayatana-appindicator3-dev \
            gcc \
            pkg-config \
            wget \
            file

          # Verify webkit2gtk-4.1 is properly installed
          pkg-config --modversion webkit2gtk-4.1 || exit 1
          echo "webkit2gtk-4.1 installed successfully for ARM64"

          # Create symlink for Wails v2 compatibility (looks for 4.0)
          sudo ln -sf /usr/lib/aarch64-linux-gnu/pkgconfig/webkit2gtk-4.1.pc /usr/lib/aarch64-linux-gnu/pkgconfig/webkit2gtk-4.0.pc
          echo "Created webkit2gtk-4.0 symlink for Wails compatibility"

      - name: Install Windows dependencies (AMD64)
        if: steps.check_artifacts.outputs.skip_build == 'false' && matrix.platform == 'windows' && matrix.arch == 'amd64'
        run: |
          choco install mingw nsis -y
        shell: pwsh

      - name: Install Windows dependencies (ARM64)
        if: steps.check_artifacts.outputs.skip_build == 'false' && matrix.platform == 'windows' && matrix.arch == 'arm64'
        run: |
          choco install mingw nsis -y
          # MinGW is required for systray (CGO)
        shell: pwsh

      - name: Install Wails
        if: steps.check_artifacts.outputs.skip_build == 'false'
        run: go install github.com/wailsapp/wails/v2/cmd/wails@latest

      - name: Install frontend dependencies
        if: steps.check_artifacts.outputs.skip_build == 'false'
        working-directory: ./frontend
        run: npm ci

      - name: Build frontend (required for embed)
        if: steps.check_artifacts.outputs.skip_build == 'false'
        working-directory: ./frontend
        run: npm run build

      - name: Build application (Linux)
        if: steps.check_artifacts.outputs.skip_build == 'false' && matrix.platform == 'linux'
        env:
          CGO_ENABLED: 1
        run: |
          wails build -clean -ldflags "-s -w" -platform ${{ matrix.platform }}/${{ matrix.arch }}

          # Verify the build
          if [ ! -f "build/bin/MrRSS" ]; then
            echo "Error: Binary not found"
            exit 1
          fi

          # Check architecture
          file build/bin/MrRSS
          echo "Binary built successfully for ${{ matrix.arch }}"

      - name: Build application (Windows)
        if: steps.check_artifacts.outputs.skip_build == 'false' && matrix.platform == 'windows'
        shell: pwsh
        env:
          CGO_ENABLED: 1
        run: |
          wails build -clean -ldflags "-s -w" -platform ${{ matrix.platform }}/${{ matrix.arch }}

          # Verify the build
          if (-not (Test-Path "build/bin/MrRSS.exe")) {
            Write-Error "Binary not created"
            exit 1
          }

          Write-Host "Binary built successfully for ${{ matrix.arch }}"

      - name: Build application (macOS)
        if: steps.check_artifacts.outputs.skip_build == 'false' && matrix.platform == 'darwin'
        env:
          CGO_ENABLED: 1
        run: |
          # macOS runners can build universal binaries natively
          # Universal binaries include both Intel (amd64) and Apple Silicon (arm64)
          wails build -clean -ldflags "-s -w" -platform ${{ matrix.platform }}/${{ matrix.arch }}

      - name: Create installer (Windows)
        if: steps.check_artifacts.outputs.skip_build == 'false' && matrix.platform == 'windows'
        run: |
          # Find NSIS installation
          $nsisPath = Get-Command makensis -ErrorAction SilentlyContinue
          if (-not $nsisPath) {
            # Try common installation paths
            $possiblePaths = @(
              "C:\Program Files (x86)\NSIS\makensis.exe",
              "C:\Program Files\NSIS\makensis.exe"
            )
            foreach ($path in $possiblePaths) {
              if (Test-Path $path) {
                $nsisPath = $path
                break
              }
            }
          } else {
            $nsisPath = $nsisPath.Source
          }

          if (-not $nsisPath) {
            Write-Error "NSIS not found"
            exit 1
          }

          Write-Host "Using NSIS at: $nsisPath"

          # Update version and architecture in installer script
          $version = "${{ needs.create-release.outputs.version }}"
          $arch = "${{ matrix.arch }}"
          $installerPath = "build/windows/installer.nsi"

          if (Test-Path $installerPath) {
            $content = Get-Content $installerPath -Raw
            $content = $content -replace '!define APP_VERSION ".*"', "!define APP_VERSION `"$version`""
            $content = $content -replace 'OutFile ".*"', "OutFile `"..\bin\MrRSS-$version-windows-$arch-installer.exe`""
            Set-Content $installerPath $content

            # Build NSIS installer
            & $nsisPath $installerPath

            if ($LASTEXITCODE -ne 0) {
              Write-Error "NSIS build failed with exit code $LASTEXITCODE"
              exit 1
            }
          } else {
            Write-Warning "Installer script not found at $installerPath"
            exit 1
          }
        shell: pwsh
        continue-on-error: true

      - name: Create portable package (Windows)
        if: steps.check_artifacts.outputs.skip_build == 'false' && matrix.platform == 'windows'
        run: |
          $version = "${{ needs.create-release.outputs.version }}"
          $arch = "${{ matrix.arch }}"
          $portableDir = "build/portable-temp"

          # Create portable directory structure
          New-Item -ItemType Directory -Force -Path $portableDir | Out-Null

          # Copy executable
          Copy-Item "build/bin/MrRSS.exe" -Destination $portableDir

          # Create portable.txt marker
          New-Item -ItemType File -Path "$portableDir/portable.txt" | Out-Null

          # Create README for portable version
          @"
          MrRSS Portable Edition

          This is the portable version of MrRSS. All data will be stored in the 'data' folder
          next to this executable.

          To run: Double-click MrRSS.exe

          For more information, visit: https://github.com/WCY-dt/MrRSS
          "@ | Out-File -FilePath "$portableDir/README.txt" -Encoding UTF8

          # Create zip file
          $zipName = "MrRSS-$version-windows-$arch-portable.zip"
          Compress-Archive -Path "$portableDir/*" -DestinationPath "build/bin/$zipName" -Force

          Write-Host "Created portable package: $zipName"
        shell: pwsh

      - name: Create installer (Linux)
        if: steps.check_artifacts.outputs.skip_build == 'false' && matrix.platform == 'linux'
        run: |
          # Clean up any cached appimagetool to ensure correct architecture is downloaded
          rm -f build/appimagetool-*.AppImage

          chmod +x build/linux/create-appimage.sh
          ARCH=${{ matrix.arch }} ./build/linux/create-appimage.sh || echo "AppImage creation failed, will use tar.gz"
        continue-on-error: true

      - name: Create installer (macOS)
        if: steps.check_artifacts.outputs.skip_build == 'false' && matrix.platform == 'darwin'
        run: |
          chmod +x build/macos/create-dmg.sh
          ./build/macos/create-dmg.sh
        continue-on-error: true

      - name: Create portable package (macOS)
        if: steps.check_artifacts.outputs.skip_build == 'false' && matrix.platform == 'darwin'
        run: |
          VERSION="${{ needs.create-release.outputs.version }}"
          ARCH="${{ matrix.arch }}"
          PORTABLE_DIR="build/portable-temp"

          # Create portable directory structure
          mkdir -p "$PORTABLE_DIR"

          # Copy .app bundle
          cp -R build/bin/MrRSS.app "$PORTABLE_DIR/"

          # Create portable.txt marker
          touch "$PORTABLE_DIR/portable.txt"

          # Create README for portable version
          cat > "$PORTABLE_DIR/README.txt" << 'EOF'
          MrRSS Portable Edition

          This is the portable version of MrRSS. All data will be stored in the 'data' folder
          next to the MrRSS.app.

          To run: Double-click MrRSS.app

          For more information, visit: https://github.com/WCY-dt/MrRSS
          EOF

          # Create zip file
          cd "$PORTABLE_DIR"
          zip -r "../bin/MrRSS-${VERSION}-darwin-${ARCH}-portable.zip" *
          cd ../..

          echo "Created portable package: MrRSS-${VERSION}-darwin-${ARCH}-portable.zip"

      - name: Package application (Linux - tar.gz fallback)
        if: steps.check_artifacts.outputs.skip_build == 'false' && matrix.platform == 'linux'
        run: |
          cd build/bin
          if [ -f "MrRSS" ]; then
            tar -czf MrRSS-${{ needs.create-release.outputs.version }}-linux-${{ matrix.arch }}.tar.gz MrRSS
          else
            echo "Error: MrRSS binary not found"
            exit 1
          fi

      - name: Create portable package (Linux)
        if: steps.check_artifacts.outputs.skip_build == 'false' && matrix.platform == 'linux'
        run: |
          VERSION="${{ needs.create-release.outputs.version }}"
          ARCH="${{ matrix.arch }}"
          PORTABLE_DIR="build/portable-temp"

          # Create portable directory structure
          mkdir -p "$PORTABLE_DIR"

          # Copy executable
          cp build/bin/MrRSS "$PORTABLE_DIR/"
          chmod +x "$PORTABLE_DIR/MrRSS"

          # Create portable.txt marker
          touch "$PORTABLE_DIR/portable.txt"

          # Create README for portable version
          cat > "$PORTABLE_DIR/README.txt" << 'EOF'
          MrRSS Portable Edition

          This is the portable version of MrRSS. All data will be stored in the 'data' folder
          next to this executable.

          To run: ./MrRSS

          For more information, visit: https://github.com/WCY-dt/MrRSS
          EOF

          # Create tar.gz file
          cd "$PORTABLE_DIR"
          tar -czf "../bin/MrRSS-${VERSION}-linux-${ARCH}-portable.tar.gz" *
          cd ../..

          echo "Created portable package: MrRSS-${VERSION}-linux-${ARCH}-portable.tar.gz"

      - name: Collect artifacts
        if: steps.check_artifacts.outputs.skip_build == 'false'
        id: collect_artifacts
        shell: bash
        run: |
          cd build/bin
          artifacts=""

          # Check for installer and portable package
          if [ "${{ matrix.platform }}" = "windows" ]; then
            installer="MrRSS-${{ needs.create-release.outputs.version }}-windows-${{ matrix.arch }}-installer.exe"
            portable="MrRSS-${{ needs.create-release.outputs.version }}-windows-${{ matrix.arch }}-portable.zip"
            if [ -f "$installer" ]; then
              artifacts="$artifacts$installer,"
            fi
            if [ -f "$portable" ]; then
              artifacts="$artifacts$portable,"
            fi
          elif [ "${{ matrix.platform }}" = "linux" ]; then
            installer="MrRSS-${{ needs.create-release.outputs.version }}-linux-${{ matrix.arch }}.AppImage"
            portable="MrRSS-${{ needs.create-release.outputs.version }}-linux-${{ matrix.arch }}-portable.tar.gz"
            if [ -f "$installer" ]; then
              artifacts="$artifacts$installer,"
            fi
            # Check for tar.gz fallback
            package="MrRSS-${{ needs.create-release.outputs.version }}-linux-${{ matrix.arch }}.tar.gz"
            if [ -f "$package" ]; then
              artifacts="$artifacts$package,"
            fi
            if [ -f "$portable" ]; then
              artifacts="$artifacts$portable,"
            fi
          elif [ "${{ matrix.platform }}" = "darwin" ]; then
            installer="MrRSS-${{ needs.create-release.outputs.version }}-darwin-${{ matrix.arch }}.dmg"
            portable="MrRSS-${{ needs.create-release.outputs.version }}-darwin-${{ matrix.arch }}-portable.zip"
            if [ -f "$installer" ]; then
              artifacts="$artifacts$installer,"
            fi
            if [ -f "$portable" ]; then
              artifacts="$artifacts$portable,"
            fi
          fi

          echo "artifacts=$artifacts" >> $GITHUB_OUTPUT
          echo "Found artifacts: $artifacts"

      - name: Upload Release Assets
        if: steps.check_artifacts.outputs.skip_build == 'false'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.create-release.outputs.tag }}
          files: |
            build/bin/MrRSS-${{ needs.create-release.outputs.version }}-*
          token: ${{ secrets.GITHUB_TOKEN }}
          fail_on_unmatched_files: false
