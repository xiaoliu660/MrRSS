version: '3'

includes:
  common: ../Taskfile.yml

vars:
  # Signing configuration - edit these values for your project
  # PGP_KEY: "path/to/signing-key.asc"
  # SIGN_ROLE: "builder"  # Options: origin, maint, archive, builder
  #
  # Password is stored securely in system keychain. Run: wails3 setup signing

  # Docker image for cross-compilation (used when building on non-Linux or no CC available)
  CROSS_IMAGE: wails-cross

tasks:
  build:
    summary: Builds the application for Linux
    cmds:
      # Linux requires CGO - use Docker when cross-compiling from non-Linux OR when no C compiler is available
      - task: '{{if and (eq OS "linux") (eq .HAS_CC "true")}}build:native{{else}}build:docker{{end}}'
        vars:
          ARCH: '{{.ARCH}}'
          DEV: '{{.DEV}}'
          OUTPUT: '{{.OUTPUT}}'
    vars:
      DEFAULT_OUTPUT: '{{.BIN_DIR}}/{{.APP_NAME}}'
      OUTPUT: '{{ .OUTPUT | default .DEFAULT_OUTPUT }}'
      # Check if a C compiler is available (gcc or clang)
      HAS_CC:
        sh: '(command -v gcc >/dev/null 2>&1 || command -v clang >/dev/null 2>&1) && echo "true" || echo "false"'

  build:native:
    summary: Builds the application natively on Linux
    internal: true
    deps:
      - task: common:go:mod:tidy
      - task: common:build:frontend
        vars:
          BUILD_FLAGS:
            ref: .BUILD_FLAGS
          DEV:
            ref: .DEV
      - task: common:generate:icons
      - task: generate:dotdesktop
    cmds:
      - go build {{.BUILD_FLAGS}} -o {{.OUTPUT}}
    vars:
      BUILD_FLAGS: '{{if eq .DEV "true"}}-buildvcs=false -gcflags=all="-l"{{else}}-tags production -trimpath -buildvcs=false -ldflags="-w -s"{{end}}'
      DEFAULT_OUTPUT: '{{.BIN_DIR}}/{{.APP_NAME}}'
      OUTPUT: '{{ .OUTPUT | default .DEFAULT_OUTPUT }}'
    env:
      GOOS: linux
      CGO_ENABLED: 1
      GOARCH: '{{.ARCH | default ARCH}}'

  build:docker:
    summary: Cross-compiles for Linux using Docker with Zig (for macOS/Windows hosts)
    internal: true
    deps:
      - task: common:build:frontend
      - task: common:generate:icons
      - task: generate:dotdesktop
    preconditions:
      - sh: docker info > /dev/null 2>&1
        msg: "Docker is required for cross-compilation to Linux. Please install Docker."
      - sh: docker image inspect {{.CROSS_IMAGE}} > /dev/null 2>&1
        msg: |
          Docker image '{{.CROSS_IMAGE}}' not found.
          Build it first: wails3 task setup:docker
    cmds:
      - docker run --rm -v "{{.ROOT_DIR}}:/app" {{.GO_CACHE_MOUNT}} {{.REPLACE_MOUNTS}} -e APP_NAME={{.APP_NAME}} {{.CROSS_IMAGE}} linux {{.DOCKER_ARCH}}
      - docker run --rm -v "{{.ROOT_DIR}}:/app" alpine chown -R $(id -u):$(id -g) /app/bin
      - mkdir -p {{.BIN_DIR}}
      - mv bin/{{.APP_NAME}}-linux-{{.DOCKER_ARCH}} {{.OUTPUT}}
    vars:
      DOCKER_ARCH: '{{.ARCH | default "amd64"}}'
      DEFAULT_OUTPUT: '{{.BIN_DIR}}/{{.APP_NAME}}'
      OUTPUT: '{{ .OUTPUT | default .DEFAULT_OUTPUT }}'
      # Mount Go module cache for faster builds
      GO_CACHE_MOUNT:
        sh: 'echo "-v ${GOPATH:-$HOME/go}/pkg/mod:/go/pkg/mod"'
      # Extract replace directives from go.mod and create -v mounts for each
      REPLACE_MOUNTS:
        sh: |
          grep -E '^replace .* => ' go.mod 2>/dev/null | while read -r line; do
            path=$(echo "$line" | sed -E 's/^replace .* => //' | tr -d '\r')
            # Convert relative paths to absolute
            if [ "${path#/}" = "$path" ]; then
              path="$(cd "$(dirname "$path")" 2>/dev/null && pwd)/$(basename "$path")"
            fi
            # Only mount if directory exists
            if [ -d "$path" ]; then
              echo "-v $path:$path:ro"
            fi
          done | tr '\n' ' '

  package:
    summary: Packages the application for Linux
    deps:
      - task: build
    cmds:
      - task: create:appimage
      - task: create:tarball

  create:appimage:
    summary: Creates an AppImage
    deps:
      - task: build
      - task: generate:dotdesktop
    cmds:
      - |
        if [ -f "build/linux/create-appimage.sh" ]; then
          chmod +x build/linux/create-appimage.sh
          ARCH={{.ARCH | default "amd64"}} ./build/linux/create-appimage.sh
        else
          echo "Warning: create-appimage.sh not found, skipping AppImage creation"
        fi

  create:tarball:
    summary: Creates a tarball package
    deps:
      - task: build
    cmds:
      - cd {{.BIN_DIR}} && tar -czf {{.APP_NAME}}-{{.VERSION}}-linux-{{.ARCH}}.tar.gz {{.APP_NAME}}
    vars:
      VERSION: '1.3.7'
      ARCH: '{{.ARCH | default "amd64"}}'

  generate:dotdesktop:
    summary: Generates a `.desktop` file
    dir: build
    cmds:
      - mkdir -p {{.ROOT_DIR}}/build/linux
      - |
        cat > {{.ROOT_DIR}}/build/linux/{{.APP_NAME}}.desktop << EOF
        [Desktop Entry]
        Name={{.APP_NAME}}
        Comment=A modern, standalone RSS reader
        Exec={{.APP_NAME}}
        Icon={{.APP_NAME}}
        Terminal=false
        Type=Application
        Categories=Network;News;
        EOF

  run:
    cmds:
      - '{{.BIN_DIR}}/{{.APP_NAME}}'

  build:server:
    summary: Builds the server version using Docker
    deps:
      - task: common:build:frontend
    cmds:
      - docker build -f Dockerfile.server -t mrrss-server:latest .
      - docker create --name mrrss-server-temp mrrss-server:latest
      - docker cp mrrss-server-temp:/app/mrrss-server {{.BIN_DIR}}/{{.APP_NAME}}-server
      - docker rm mrrss-server-temp
    preconditions:
      - sh: docker info > /dev/null 2>&1
        msg: "Docker is required for building the server version"

  run:server:
    summary: Runs the server version
    deps:
      - task: build:server
    cmds:
      - '{{.BIN_DIR}}/{{.APP_NAME}}-server'
